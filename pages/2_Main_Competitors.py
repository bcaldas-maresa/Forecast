import streamlit as st
import pandas as pd
import json
from sqlalchemy import text, bindparam
from auth import get_db_engine
from sidebar import render_sidebar



# =========================
# Seguridad / Login
# =========================
if st.session_state.get("logged_in", False) is False:
    st.error("Por favor, inicie sesiÃ³n primero para acceder a esta pÃ¡gina.")
    st.page_link("app.py", label="Ir a Login", icon="ðŸ ")
    st.stop()

render_sidebar()

OWN_BRANDS = ["DONGFENG", "MAZDA", "JEEP", "RAM", "CHERY", "FIAT", "DODGE"]

# UI
COMP_TYPE_OPTIONS = ["Resto MKT", "Directa", "Indirecta"]
COMP_TYPE_SAVE_OPTIONS = ["Directa", "Indirecta"]  # Guardado permitido

# =========================
# DB helpers
# =========================
def ensure_main_competitor_tables(engine):
    ddl_main = """
    CREATE TABLE IF NOT EXISTS vehicle_main_competitor (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

        own_brand VARCHAR(100) NOT NULL,
        own_familia VARCHAR(150) NOT NULL,
        own_modelo VARCHAR(150) NOT NULL,

        competitor_brand VARCHAR(100) NOT NULL,
        competitor_familia VARCHAR(150) NULL,
        competitor_modelo VARCHAR(150) NOT NULL,

        competition_type VARCHAR(20) NOT NULL,
        notes TEXT NULL,

        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        created_by VARCHAR(255) NULL,
        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_by VARCHAR(255) NULL
    );
    """

    ddl_hist = """
    CREATE TABLE IF NOT EXISTS vehicle_main_competitor_history (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        main_id BIGINT NULL,
        action VARCHAR(10) NOT NULL,
        changed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        changed_by VARCHAR(255) NULL,
        old_row_json TEXT NULL,
        new_row_json TEXT NULL
    );
    """

    # âœ… â€œmigraciÃ³nâ€ para tablas existentes (NO lo hace CREATE TABLE IF NOT EXISTS)
    ddl_fix = """
    ALTER TABLE vehicle_main_competitor
    ADD COLUMN IF NOT EXISTS pair_hash bytea
    GENERATED ALWAYS AS (
      decode(
        md5(
          'ob=' || COALESCE(own_brand,'') ||
          '|of=' || COALESCE(own_familia,'') ||
          '|om=' || COALESCE(own_modelo,'') ||
          '|cb=' || COALESCE(competitor_brand,'') ||
          '|cf=' || COALESCE(competitor_familia,'') ||
          '|cm=' || COALESCE(competitor_modelo,'')
        ),
        'hex'
      )
    ) STORED;

    CREATE UNIQUE INDEX IF NOT EXISTS uq_main_competitor_pair_hash
    ON vehicle_main_competitor (pair_hash);

    CREATE INDEX IF NOT EXISTS idx_main_competitor_own
    ON vehicle_main_competitor (own_brand, own_familia, own_modelo);

    CREATE INDEX IF NOT EXISTS idx_main_comp_hist_main_id
    ON vehicle_main_competitor_history (main_id);
    """

    with engine.begin() as conn:
        conn.execute(text(ddl_main))
        conn.execute(text(ddl_hist))
        conn.execute(text(ddl_fix))

def ensure_unique_pair_index(engine):
    """
    En Postgres no hace falta (ya lo crea ensure_main_competitor_tables con UNIQUE(pair_hash)).
    En MySQL se podrÃ­a migrar aquÃ­, pero si ya creas con DDL arriba, tambiÃ©n es innecesario.
    """
    return


def upsert_competitor(engine, payload, user_email):
    """
    Inserta/actualiza un competitor especÃ­fico para un own (par own+competitor).
    Guarda historial.
    """
    ensure_main_competitor_tables(engine)
    dialect = engine.dialect.name

    old_df = pd.read_sql(
        text("""
            SELECT *
            FROM vehicle_main_competitor
            WHERE own_brand=:ob AND own_familia=:of AND own_modelo=:om
              AND competitor_brand=:cb AND competitor_familia=:cf AND competitor_modelo=:cm
            LIMIT 1
        """),
        engine,
        params={
            "ob": payload["own_brand"], "of": payload["own_familia"], "om": payload["own_modelo"],
            "cb": payload["competitor_brand"], "cf": payload["competitor_familia"], "cm": payload["competitor_modelo"],
        }
    )
    old = None if old_df.empty else old_df.iloc[0].to_dict()

    params = dict(payload)
    params["created_by"] = user_email
    params["updated_by"] = user_email

    if dialect == "postgresql":
        sql = text("""
            INSERT INTO vehicle_main_competitor (
              own_brand, own_familia, own_modelo,
              competitor_brand, competitor_familia, competitor_modelo,
              competition_type, notes,
              created_by, updated_by, updated_at
            )
            VALUES (
              :own_brand, :own_familia, :own_modelo,
              :competitor_brand, :competitor_familia, :competitor_modelo,
              :competition_type, :notes,
              :created_by, :updated_by, CURRENT_TIMESTAMP
            )
            ON CONFLICT (pair_hash) DO UPDATE
            SET
              competition_type = EXCLUDED.competition_type,
              notes = EXCLUDED.notes,
              updated_by = EXCLUDED.updated_by,
              updated_at = CURRENT_TIMESTAMP
        """)
    else:
        sql = text("""
            INSERT INTO vehicle_main_competitor (
              own_brand, own_familia, own_modelo,
              competitor_brand, competitor_familia, competitor_modelo,
              competition_type, notes,
              created_by, updated_by, updated_at
            )
            VALUES (
              :own_brand, :own_familia, :own_modelo,
              :competitor_brand, :competitor_familia, :competitor_modelo,
              :competition_type, :notes,
              :created_by, :updated_by, NOW()
            )
            ON DUPLICATE KEY UPDATE
              competition_type=VALUES(competition_type),
              notes=VALUES(notes),
              updated_by=VALUES(updated_by),
              updated_at=NOW()
        """)

    with engine.begin() as conn:
        conn.execute(sql, params)

        new_df = pd.read_sql(
            text("""
                SELECT *
                FROM vehicle_main_competitor
                WHERE own_brand=:ob AND own_familia=:of AND own_modelo=:om
                  AND competitor_brand=:cb AND competitor_familia=:cf AND competitor_modelo=:cm
                LIMIT 1
            """),
            conn,
            params={
                "ob": payload["own_brand"], "of": payload["own_familia"], "om": payload["own_modelo"],
                "cb": payload["competitor_brand"], "cf": payload["competitor_familia"], "cm": payload["competitor_modelo"],
            }
        )
        new_row = None if new_df.empty else new_df.iloc[0].to_dict()

        action = "INSERT" if old is None else "UPDATE"
        conn.execute(
            text("""
                INSERT INTO vehicle_main_competitor_history
                  (main_id, action, changed_by, old_row_json, new_row_json)
                VALUES
                  (:main_id, :action, :changed_by, :old_row_json, :new_row_json)
            """),
            {
                "main_id": int(new_row["id"]) if new_row and new_row.get("id") else None,
                "action": action,
                "changed_by": user_email,
                "old_row_json": json.dumps(old, default=str, ensure_ascii=False) if old else None,
                "new_row_json": json.dumps(new_row, default=str, ensure_ascii=False) if new_row else None,
            },
        )

    return old, new_row

def delete_competitor(engine, own_brand, own_familia, own_modelo, comp_brand, comp_familia, comp_modelo, user_email):
    """
    Elimina un competitor especÃ­fico.
    Guarda historial.
    """
    ensure_main_competitor_tables(engine)

    old_df = pd.read_sql(
        text("""
            SELECT *
            FROM vehicle_main_competitor
            WHERE own_brand=:ob AND own_familia=:of AND own_modelo=:om
              AND competitor_brand=:cb AND competitor_familia=:cf AND competitor_modelo=:cm
            LIMIT 1
        """),
        engine,
        params={
            "ob": own_brand, "of": own_familia, "om": own_modelo,
            "cb": comp_brand, "cf": comp_familia, "cm": comp_modelo,
        }
    )
    if old_df.empty:
        return None

    old = old_df.iloc[0].to_dict()

    with engine.begin() as conn:
        conn.execute(
            text("""
                DELETE FROM vehicle_main_competitor
                WHERE own_brand=:ob AND own_familia=:of AND own_modelo=:om
                  AND competitor_brand=:cb AND competitor_familia=:cf AND competitor_modelo=:cm
            """),
            {
                "ob": own_brand, "of": own_familia, "om": own_modelo,
                "cb": comp_brand, "cf": comp_familia, "cm": comp_modelo,
            }
        )
        conn.execute(
            text("""
                INSERT INTO vehicle_main_competitor_history (main_id, action, changed_by, old_row_json, new_row_json)
                VALUES (:main_id, 'DELETE', :changed_by, :old_row_json, NULL)
            """),
            {
                "main_id": int(old["id"]) if old.get("id") else None,
                "changed_by": user_email,
                "old_row_json": json.dumps(old, default=str, ensure_ascii=False),
            }
        )

    return old

@st.cache_data(ttl=300)
def load_dim_vehicle_versions():
    """
    Carga el catÃ¡logo desde dim_vehicle_versions.
    Fallback a sales_granular DISTINCT si dim no existe.
    """
    engine = get_db_engine()

    try:
        df = pd.read_sql(
            """
            SELECT marca, familia, modelo, segmento, tipo_combustible, origen, tipo_hibridacion
            FROM dim_vehicle_versions
            """,
            engine,
        )
    except Exception:
        df = pd.read_sql(
            """
            SELECT DISTINCT marca, familia, modelo, segmento, tipo_combustible, origen, tipo_hibridacion
            FROM sales_granular
            """,
            engine,
        )

    for c in ["marca", "familia", "modelo"]:
        df[c] = df[c].fillna("No Especificado").astype(str).str.strip()
        df[c] = df[c].replace("", "No Especificado")

    return df

def get_assigned_competitors(engine, own_brand, own_familia, own_modelo):
    ensure_main_competitor_tables(engine)
    q = text("""
        SELECT *
        FROM vehicle_main_competitor
        WHERE own_brand=:ob AND own_familia=:of AND own_modelo=:om
        ORDER BY updated_at DESC
    """)
    return pd.read_sql(q, engine, params={"ob": own_brand, "of": own_familia, "om": own_modelo})

@st.cache_data(ttl=300)
def load_own_versions_sold_l12m(own_brands):
    """
    Devuelve solo las versiones (marca/familia/modelo) que tuvieron ventas
    en los Ãºltimos 12 meses (relativo a la max(fecha_proceso) en sales_granular)
    y solo para las marcas propias (OWN_BRANDS).
    """
    engine = get_db_engine()

    sql = text("""
        WITH maxd AS (
            SELECT MAX(fecha_proceso)::date AS max_fecha
            FROM sales_granular
        )
        SELECT
            UPPER(marca) AS marca,
            COALESCE(NULLIF(TRIM(familia), ''), 'No Especificado') AS familia,
            COALESCE(NULLIF(TRIM(modelo), ''), 'No Especificado') AS modelo
        FROM sales_granular, maxd
        WHERE fecha_proceso >= (maxd.max_fecha - INTERVAL '12 months')
          AND UPPER(marca) IN :brands
        GROUP BY 1, 2, 3
        HAVING COALESCE(SUM(unidades), 0) > 0
        ORDER BY 1, 2, 3
    """).bindparams(bindparam("brands", expanding=True))

    df = pd.read_sql(sql, engine, params={"brands": [b.upper() for b in own_brands]})
    return df

# =========================
# UI
# =========================
st.title("ðŸš— MAIN COMPETITOR")
st.caption(
    "Selecciona un modelo/versiÃ³n de tu marca y asigna sus *main competitors*. "
    "Puedes marcar varios competitors a la vez. "
    "Si marcas un competitor, debes definir si la competencia es **Directa** o **Indirecta**."
)

engine = get_db_engine()
user_email = st.session_state.get("email", "")

df_own_l12m  = load_own_versions_sold_l12m(OWN_BRANDS)    # SOLO propios vendidos L12M (para selecciÃ³n 1)
df_dim = load_dim_vehicle_versions()
if df_dim.empty:
    st.warning("No hay catÃ¡logo disponible. Verifica dim_vehicle_versions o sales_granular.")
    st.stop()

# -------------------------
# 1) SelecciÃ³n del "propio" (desplegables: Marca -> Familia -> VersiÃ³n)
# -------------------------
st.subheader("1) Selecciona el modelo/versiÃ³n de tu marca")

c1, c2, c3 = st.columns([0.25, 0.4, 0.35])
with c1:
    own_brand = st.selectbox("Marca (propia)", options=OWN_BRANDS, index=0)

df_own = df_own_l12m[df_own_l12m["marca"].astype(str).str.upper() == str(own_brand).upper()].copy()
df_own["familia"] = df_own["familia"].fillna("No Especificado").astype(str)
df_own["modelo"] = df_own["modelo"].fillna("No Especificado").astype(str)

familia_opts = sorted(df_own["familia"].unique().tolist()) if not df_own.empty else []
if not familia_opts:
    st.warning("No hay familias/modelos para la marca seleccionada.")
    st.stop()

with c2:
    own_familia = st.selectbox("Modelo (Familia)", options=familia_opts, index=0)

df_own2 = df_own[df_own["familia"].astype(str) == str(own_familia)].copy()
modelo_opts = sorted(df_own2["modelo"].unique().tolist()) if not df_own2.empty else []
if not modelo_opts:
    st.warning("No hay versiones para la familia seleccionada.")
    st.stop()

with c3:
    own_modelo = st.selectbox("VersiÃ³n (Modelo)", options=modelo_opts, index=0)

st.divider()

# -------------------------
# 2) Competitors asignados actualmente (editar tipo + eliminar mÃºltiples)
# -------------------------
st.subheader("2) Competitors asignados actualmente")

df_assigned = get_assigned_competitors(engine, own_brand, own_familia, own_modelo)

assigned_set = set(
    zip(
        df_assigned["competitor_brand"].astype(str),
        df_assigned["competitor_familia"].astype(str),
        df_assigned["competitor_modelo"].astype(str),
    )
) if not df_assigned.empty else set()

assigned_type_map = {}
if not df_assigned.empty:
    for _, r in df_assigned.iterrows():
        k = (str(r["competitor_brand"]), str(r["competitor_familia"]), str(r["competitor_modelo"]))
        assigned_type_map[k] = str(r.get("competition_type") or "Indirecta")

if df_assigned.empty:
    st.info("No hay competitors asignados todavÃ­a para esta versiÃ³n.")
else:
    df_assigned_show = df_assigned[[
        "competitor_brand", "competitor_familia", "competitor_modelo",
        "competition_type", "updated_by", "updated_at"
    ]].copy()

    df_assigned_show = df_assigned_show.rename(columns={
        "competitor_brand": "Marca",
        "competitor_familia": "Modelo (Familia)",
        "competitor_modelo": "VersiÃ³n (Modelo)",
        "competition_type": "Tipo Competencia",
        "updated_by": "Actualizado por",
        "updated_at": "Actualizado el",
    })

    st.markdown("**Editar tipo de competencia (Directa/Indirecta):**")
    edited_assigned = st.data_editor(
        df_assigned_show,
        hide_index=True,
        use_container_width=True,
        num_rows="fixed",
        column_config={
            "Tipo Competencia": st.column_config.SelectboxColumn(
                "Tipo Competencia",
                options=COMP_TYPE_SAVE_OPTIONS,
                required=True,
            )
        },
        disabled=["Marca", "Modelo (Familia)", "VersiÃ³n (Modelo)", "Actualizado por", "Actualizado el"],
        key="assigned_editor",
    )

    if st.button("Guardar cambios de tipo", type="primary"):
        changes = []
        for _, r in edited_assigned.iterrows():
            k = (str(r["Marca"]), str(r["Modelo (Familia)"]), str(r["VersiÃ³n (Modelo)"]))
            new_type = str(r["Tipo Competencia"])
            old_type = assigned_type_map.get(k, "Indirecta")
            if new_type != old_type:
                changes.append((k, old_type, new_type))

        if not changes:
            st.info("No hay cambios de tipo para guardar.")
        else:
            for (k, _, new_type) in changes:
                payload = {
                    "own_brand": own_brand,
                    "own_familia": own_familia,
                    "own_modelo": own_modelo,
                    "competitor_brand": k[0],
                    "competitor_familia": k[1],
                    "competitor_modelo": k[2],
                    "competition_type": new_type,
                    "notes": None,
                }
                upsert_competitor(engine, payload, user_email)

            st.cache_data.clear()
            st.success(f"Tipos actualizados: {len(changes)}")
            st.rerun()

    st.markdown("**Eliminar competitors (puedes seleccionar varios):**")
    edited_assigned["key"] = (
        edited_assigned["Marca"].astype(str)
        + " / " + edited_assigned["Modelo (Familia)"].astype(str)
        + " / " + edited_assigned["VersiÃ³n (Modelo)"].astype(str)
    )
    to_del_list = st.multiselect(
        "Selecciona competitors a eliminar",
        options=edited_assigned["key"].tolist(),
        default=[],
    )

    if to_del_list:
        st.warning(f"Vas a eliminar **{len(to_del_list)}** competitor(s). QuedarÃ¡ registro en historial.")
        colx, coly = st.columns([0.25, 0.75])
        with colx:
            if st.button("Confirmar eliminaciÃ³n", type="primary"):
                for item in to_del_list:
                    parts = [p.strip() for p in item.split("/")]
                    delete_competitor(
                        engine,
                        own_brand, own_familia, own_modelo,
                        parts[0], parts[1], parts[2],
                        user_email
                    )
                st.cache_data.clear()
                st.success("EliminaciÃ³n completada.")
                st.rerun()
        with coly:
            if st.button("Cancelar eliminaciÃ³n"):
                st.rerun()

st.divider()

# -------------------------
# 3) Agregar competitors (solo NO asignados) - mÃºltiples a la vez
# -------------------------
st.subheader("3) Agregar competitors")

# Base de candidatos: todo menos el propio exacto
df_candidates = df_dim[
    ~(
        (df_dim["marca"].astype(str) == str(own_brand))
        & (df_dim["familia"].astype(str) == str(own_familia))
        & (df_dim["modelo"].astype(str) == str(own_modelo))
    )
].copy()

# Quitar los ya asignados del listado (solo deben verse en secciÃ³n 2)
if assigned_set:
    df_candidates["_k"] = list(
        zip(
            df_candidates["marca"].astype(str),
            df_candidates["familia"].astype(str),
            df_candidates["modelo"].astype(str),
        )
    )
    df_candidates = df_candidates[~df_candidates["_k"].isin(assigned_set)].copy()
    df_candidates = df_candidates.drop(columns=["_k"], errors="ignore")

if df_candidates.empty:
    st.info("No hay candidatos disponibles (o ya asignaste todos los posibles).")
    st.stop()

# Filtro por marca competidor primero
brand_opts = ["(Todas)"] + sorted(df_candidates["marca"].astype(str).unique().tolist())
comp_brand = st.selectbox("Filtrar competidor por Marca", options=brand_opts, index=0)
if comp_brand != "(Todas)":
    df_candidates = df_candidates[df_candidates["marca"].astype(str) == comp_brand].copy()

# Luego bÃºsqueda por familia/modelo
comp_search = st.text_input("Buscar competidor (Familia o VersiÃ³n)", value="")
if comp_search.strip():
    q = comp_search.strip().lower()
    df_candidates = df_candidates[
        df_candidates["familia"].astype(str).str.lower().str.contains(q)
        | df_candidates["modelo"].astype(str).str.lower().str.contains(q)
    ].copy()

df_show = df_candidates[["marca", "familia", "modelo"]].copy()
df_show = df_show.rename(columns={
    "marca": "Marca",
    "familia": "Modelo (Familia)",
    "modelo": "VersiÃ³n (Modelo)",
})

# Orden requerido: marca, modelo, versiÃ³n, check, tipo
df_show["Main competitor"] = False
df_show["Tipo Competencia"] = "Resto MKT"

df_show = df_show[["Marca", "Modelo (Familia)", "VersiÃ³n (Modelo)", "Main competitor", "Tipo Competencia"]]

edited = st.data_editor(
    df_show,
    hide_index=True,
    use_container_width=True,
    num_rows="fixed",
    column_config={
        "Main competitor": st.column_config.CheckboxColumn(
            "Main competitor",
            help="Marca uno o varios modelos como main competitor."
        ),
        "Tipo Competencia": st.column_config.SelectboxColumn(
            "Tipo Competencia",
            options=COMP_TYPE_OPTIONS,
            required=True,
            help="Por defecto es 'Resto MKT'. Si marcas un competitor, debes escoger Directa o Indirecta para poder guardar."
        ),
    },
    key="candidates_editor",
)

# ---- Guardado en 2 pasos: preparar -> confirmar
if "pending_main_comp_add" not in st.session_state:
    st.session_state["pending_main_comp_add"] = None

if st.button("Preparar guardado (competitors marcados)", type="primary"):
    picked = edited[edited["Main competitor"] == True].copy()

    if picked.empty:
        st.info("No has marcado ningÃºn competitor.")
        st.session_state["pending_main_comp_add"] = None
    else:
        invalid = picked[~picked["Tipo Competencia"].astype(str).isin(COMP_TYPE_SAVE_OPTIONS)].copy()
        if not invalid.empty:
            msg = "Para guardar, estos competitors deben tener **Directa** o **Indirecta**:\n\n"
            for _, r in invalid.iterrows():
                msg += f"- {r['Marca']} / {r['Modelo (Familia)']} / {r['VersiÃ³n (Modelo)']} (actual: {r['Tipo Competencia']})\n"
            st.error(msg)
            st.session_state["pending_main_comp_add"] = None
        else:
            payloads = []
            for _, r in picked.iterrows():
                payloads.append({
                    "own_brand": own_brand,
                    "own_familia": own_familia,
                    "own_modelo": own_modelo,
                    "competitor_brand": str(r["Marca"]),
                    "competitor_familia": str(r["Modelo (Familia)"]),
                    "competitor_modelo": str(r["VersiÃ³n (Modelo)"]),
                    "competition_type": str(r["Tipo Competencia"]),
                    "notes": None,
                })

            st.session_state["pending_main_comp_add"] = payloads

if st.session_state.get("pending_main_comp_add"):
    payloads = st.session_state["pending_main_comp_add"]
    st.warning(
        f"EstÃ¡s por asignar **{len(payloads)}** main competitor(s) para "
        f"**{own_brand} / {own_familia} / {own_modelo}**. Â¿Confirmas?"
    )
    with st.expander("Ver detalle", expanded=False):
        for p in payloads:
            st.write(f"- {p['competitor_brand']} / {p['competitor_familia']} / {p['competitor_modelo']} â†’ **{p['competition_type']}**")

    c_ok, c_no = st.columns([0.25, 0.75])
    with c_ok:
        if st.button("Confirmar guardado", type="primary"):
            for p in payloads:
                upsert_competitor(engine, p, user_email)
            st.session_state["pending_main_comp_add"] = None
            st.cache_data.clear()
            st.success("Competitors guardados.")
            st.rerun()
    with c_no:
        if st.button("Cancelar"):
            st.session_state["pending_main_comp_add"] = None
            st.rerun()